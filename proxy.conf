# For local Docker runs:
# resolver 127.0.0.11;
# For Fly
resolver 8.8.8.8;
lua_package_path "/etc/nginx/conf.d/?.lua;;";
lua_shared_dict my_limit_req_store 100m;
server {
    listen 80;

    location /api/ {
        access_by_lua_block {
            -- well, we could put the require() and new() calls in our own Lua
            -- modules to save overhead. here we put them below just for
            -- convenience.

            local limit_req = require "resty.limit.req"

            -- limit the requests under 200 req/sec with a burst of 100 req/sec,
            -- that is, we delay requests under 300 req/sec and above 200
            -- req/sec, and reject any requests exceeding 300 req/sec.
            local lim, err = limit_req.new("my_limit_req_store", .5, .5)
            if not lim then
                ngx.log(ngx.ERR,
                        "failed to instantiate a resty.limit.req object: ", err)
                return ngx.exit(500)
            end

            -- the following call must be per-request.
            -- here we use the remote (IP) address as the limiting key
            local key = ngx.var.binary_remote_addr
            local delay, err = lim:incoming(key, true)
            if err == "rejected" then
                ngx.log(ngx.ERR, "Limit reched: ", err)
                return ngx.exit(503)
            end


            -- REDIS STUFF --
            local redis = require "resty.redis"
            local red = redis:new()

            red:set_timeouts(1000, 1000, 1000) -- 1 sec

            splitter = require("split")
            ngx.log(ngx.ERR, os.getenv("FLY_REDIS_CACHE_URL"))
            parts = splitter.split(os.getenv("FLY_REDIS_CACHE_URL"), ":@")

            -- Local
            -- local ok, err = red:connect(parts[4], parts[5])
            -- Fly
            local ok, err = red:connect(parts[4], parts[5])

            if not ok then
                ngx.log(ngx.ERR, "failed to connect: ", err)
                return
            end

            -- Fly
            local res, err = red:auth(parts[3])
            if not res then
                ngx.log(ngx.ERR, "failed to authenticate: ", err)
                return
            end

            -- Cache endpoint results
            local res, err = red:get(ngx.var.arg_key)
            if not res then
                ngx.log(ngx.ERR, "Invalid key: ", err)
                return ngx.exit(401)
            end
            if res == ngx.null then
                ngx.log(ngx.ERR, "Invalid key: ", err)
                return ngx.exit(401)
            end

            -- Close the connection
            local ok, err = red:close()
            if not ok then
                ngx.say("failed to close: ", err)
                return
            end
        }

        proxy_pass http://jsonplaceholder.typicode.com/posts/;
    }

    location /admin/ {
        access_by_lua_block {
            -- REDIS STUFF --
            local redis = require "resty.redis"
            local red = redis:new()

            red:set_timeouts(1000, 1000, 1000) -- 1 sec

            splitter = require("split")
            ngx.log(ngx.ERR, os.getenv("FLY_REDIS_CACHE_URL"))
            parts = splitter.split(os.getenv("FLY_REDIS_CACHE_URL"), ":@")

            -- Local
            -- local ok, err = red:connect(parts[4], parts[5])
            -- Fly
            local ok, err = red:connect(parts[4], parts[5])

            if not ok then
                ngx.log(ngx.ERR, "failed to connect: ", err)
                return
            end

            -- Fly
            local res, err = red:auth(parts[3])
            if not res then
                ngx.log(ngx.ERR, "failed to authenticate: ", err)
                return
            end

            ok, err = red:set("oVr0mDgJejSmb9jwXp6B", 1)
            ok, err = red:set("AstIqxOHpyAToCwh8qeL", 2)
            ok, err = red:set("eaFW03Pjp27ZbgqpgqJQ", 3)
            ok, err = red:set("PDJSIyX4cosj9RGQ5jMn", 4)
            if not ok then
                ngx.say("Failed to save API Keys: ", err)
                return
            end

            -- Close the connection
            local ok, err = red:close()
            if not ok then
                ngx.log(ngx.ERR, "failed to close: ", err)
                return
            end
        }
    }
}
